WHAT'S THIS?
============

This document contains a list of various deficiencies in Coin that are
not "large enough" to warrant them being listed as full projects in
the docs/projects.txt file, and probably not "small enough" to be
fixed within an hour or two.

See also the api-wish-list.txt file for other "mini" projects.


Important note: I (mortene@sim.no) believe it would in general be a
good idea if as many as possible of the SIM developers involved in
Coin development "cleaned the table" to make time for a "Coin2" summit
well before we are closing in on a release date for version
2.0.0. Preferably such a summit could be held for a number of days,
maybe even as much as ~ a whole week.

The reasons for this is that there's quite a number of important
design issues for all the new functionality (implemented and planned)
we should *really* think through before setting them in stone, as we
don't want to end up with second-rate API-stuff that we have to
support indefinitely in future Coin versions.

So presentations and round-table discussions around API-extensions for
Coin v2 would be a Really Good Thing to plan for -- sometime in late
Q1 2002 or early Q2 2002, perhaps.



STUFF TO FIX IN COIN
====================

* Bounding box rendering, major performance optimization
  2001-11-24  Morten Eriksen  <mortene@sim.no>

  Bounding boxes are now always recalculated when used for
  rendering. See the relevant code in SoShape::shouldGLRender().

  A huge speed-up when rendering bboxes instead of geometry could be
  had if SoShape nodes kept a bounding box cache in the same manner as
  SoSeparator nodes.


* Improve error reporting on texture loading
  2001-11-24  Morten Eriksen  <mortene@sim.no>

  The only message one can get now is "Couldn't load texture
  blablabla". This is a rather lousy error message for both the
  end-user and for the application programmer.

  We should have code which could at least recognize and spit out
  error messages in these categories:

        * no texture loading library available (which is only simage
          at the moment, but could be others)

        * could not find texture file <filename> in any of these
          directories: <searchlist>

        * found texture file at <fullfilename>, but does not recognize
          file format

        * found texture file at <fullfilename>, but file seems
          damaged

  The place to start is SbImage, but SbImage's "clients" might also
  needs changes. We will probably also have to fix libsimage to make
  more specific error reports.


* A "stopwatch" for built-in profiling support
  2001-11-27  Morten Eriksen  <mortene@sim.no>

  Support for on-the-fly profiling would be very nice. It could help
  us with the heuristics for the OpenGL displaylist render caching,
  for instance.

  We can't use the real-time time of day for this -- we need to
  measure the process/CPU-time for just the current thread to get
  proper data for this type of profiling.

  There's an ANSI C function -- clock() -- which gives us the CPU
  time used by a process.

  If that doesn't do what we want, on MSWin we could use
  GetProcessTimes() or GetThreadTimes(), and there's a POSIX function
  for doing it on UNIX-style platforms; times() (plus we need to use
  the POSIX sysconf(_SC_CLK_TCK) to find the clocktick value to
  multiply with).

  Interface suggestion:

        cc_time cc_time_get_cpu_time()  (public C++ API: SbTime::getCPUTime())

  ..and then a "stopwatch-like" interface on top of that:

        cc_stopwatch * cc_stopwatch_create(void)
        void cc_stopwatch_start(cc_stopwatch *)
        cc_time cc_stopwatch_stop(cc_stopwatch *)
        void cc_stopwatch_destroy(cc_stopwatch *)

  ..where cc_stopwatch would simply be

        struct cc_stopwatch {
          cc_time start;
        };

  ..or perhaps it could be just a

        typedef cc_time cc_stopwatch;


  One possible "gotcha": the OS-specific cpu-time functions must have
  a resolution high enough to time even very short intervals for this
  to be useful, I would assume. Perhaps a

        cc_time cc_time_get_cpu_time_resolution(void)

  would be a good idea.


* Heed the SoBoundingBoxCache::hasLinesOrPoints() settings
  2001-11-27  Morten Eriksen  <mortene@sim.no>

  We should add a slack value to bounding boxes with lines and/or
  points in them, to avoid clipping artifacts when anti-aliasing is
  used.

  (This concerns both client code in the Coin library and in the So*
  libraries which calculates and renders bounding boxes.)

  As part of this, we should audit to check that all relevant
  shape-type nodes uses the SoBoundingBoxCaches::setHasLinesOrPoints()
  method.


* Clean up the file versioning mess
  2001-11-28  Morten Eriksen  <mortene@sim.no>

  Scenegraphs exported through the SoWriteAction should have a correct
  header to reflect the actual contents. As it is now, everything is
  just written as Inventor v2.1, even if there are nodes from Inventor
  >2.1, or nodes specific for Coin.

  To make it possible to do this, it seems likely that we need some
  way of tagging API elements that can be exported to file -- ie
  primarily nodes and engines -- with some kind of versioning
  identification. So that's a prerequisite.


* Re-design the public API for handling textures
  2001-11-28  Peder Blekken  <pederb@sim.no>, write-down by mortene@sim.no

  The available public API for handling textures from SGI / TGS
  Inventor (ie SoTexture2 with friends) is seriously under-developed,
  and contains many flaws.

  Our work on a project where we developed a very advanced
  terrain-visualization extension has resulted in lots of extra
  functionality in Coin (SoGLImage, SoGLBigImage, delayed, parallel
  loading of textures in SbImage, etc etc) which will strengthen the
  support for texture handling immensely. Because of the limitations
  of the basic SoTexture2 (et al) design, it seems hard to retrofit
  this into the current design in a pretty way, though.

  So what should be done is to make a new design where all of this is

        a) fitted into the *basic* Inventor API design principles, but
           in new classes

        b) still hide as much complexity as possible for the
           application programmer, while still retaining the necessary
           level of flexibility

        c) if possible, layer the present public API classes and
            methods (ie SoTexture2 et al again) on top of the new,
            good design

        d) make sure we keep the old API functioning as before for the
           sake of compatibility with external client applications

  All this should _absolutely_ be done before we close up on the v2
  release, as after v2 it will likely be a while until we get the
  chance to do larger API / design changes again.
