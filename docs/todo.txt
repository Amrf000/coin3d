WHAT'S THIS?
============

This document contains a list of various deficiencies in Coin that are
not "large enough" to warrant them being listed as full projects in
the docs/projects.txt file, and probably not "small enough" to be
fixed within an hour or two.

See also the api-wish-list.txt file for other "mini" projects.


STUFF TO FIX IN COIN
====================

* Bounding box rendering, major performance optimization
  2001-11-24  Morten Eriksen  <mortene@sim.no>

  Bounding boxes are now always recalculated when used for
  rendering. See the relevant code in SoShape::shouldGLRender().

  A huge speed-up when rendering bboxes instead of geometry could be
  had if SoShape nodes kept a bounding box cache in the same manner as
  SoSeparator nodes.


* Improve error reporting on texture loading
  2001-11-24  Morten Eriksen  <mortene@sim.no>

  The only message one can get now is "Couldn't load texture
  blablabla". This is a rather lousy error message for both the
  end-user and for the application programmer.

  We should have code which could at least recognize and spit out
  error messages in these categories:

        * no texture loading library available (which is only simage
          at the moment, but could be others)

        * could not find texture file <filename> in any of these
          directories: <searchlist>

        * found texture file at <fullfilename>, but does not recognize
          file format

        * found texture file at <fullfilename>, but file seems
          damaged

  The place to start is SbImage, but SbImage's "clients" might also
  needs changes. We will probably also have to fix libsimage to make
  more specific error reports.


* A "stopwatch" for built-in profiling support
  2001-11-27  Morten Eriksen  <mortene@sim.no>

  Support for on-the-fly profiling would be very nice. It could help
  us with the heuristics for the OpenGL displaylist render caching,
  for instance.

  We can't use the real-time time of day for this -- we need to
  measure the process/CPU-time for just the current thread to get
  proper data for this type of profiling.

  On MSWin we could use "GetProcessTimes()" and there's a POSIX
  function for doing it on UNIX-style platforms; "times()" (plus we
  need to use the POSIX "sysconf(_SC_CLK_TCK)" to find the clocktick
  value to multiply with).

  On Mac it looks like there's a function "clock()" which does
  something similar. Also, I expect Mac OS X to have the POSIX times()
  and sysconf() methods.

  Interface suggestion:

        cc_time cc_time_get_cpu_time()  (public C++ API: SbTime::getCPUTime())

  ..and then a "stopwatch-like" interface on top of that:

        cc_stopwatch * cc_stopwatch_create(void)
        void cc_stopwatch_start(cc_stopwatch *)
        cc_time cc_stopwatch_stop(cc_stopwatch *)
        void cc_stopwatch_destroy(cc_stopwatch *)

  ..where cc_stopwatch would simply be

        struct cc_stopwatch {
          cc_time start;
        };

  ..or perhaps it could be just a

        typedef cc_time cc_stopwatch;


  One possible "gotcha": the OS-specific cpu-time functions must have
  a resolution high enough to time even very short intervals for this
  to be useful, I would assume.
