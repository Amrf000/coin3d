If you want to work _with_ the Coin sourcecode (not just writing
applications _using_ the Coin library) -- for helping us fixing bugs,
improve performance, or whatever reasons -- this file contains some
hints and tips for you.

==============================================================================

1 The Bleeding Edge
===================

First of all, you should make sure you are building from the latest
sources from the CVS branch you want to work with. This is done by
using the Concurrent Versioning System for staying in sync with the
sourcecode repository we at Systems in Motion are using. Follow the
instructions on the webpages at <URL:http://www.coin3d.org>.

If you are not familiar with CVS, check out the CVS homepages at
<URL:http://cvshome.org>.


2 Surviving a Large C++ Project
===============================

The main problem all large C or C++ projects bump into sooner or later
is that the turn-around time for doing compile, link and run gets too
long for development to be efficient. When we're talking re-linking of
library files of >30MB (with debug information), its gonna get painful
to do rapid incremental bugfixing / testing cycles.

So I'm going to explain now how we at SIM have (more or less
fundamentally) solved this problem for our core Coin library. First of
all: use a "UNIX-like" system. MSWindows systems are no good for
working with the kind of setup we have, we do all new development on
UNIX systems (mostly Linux and SGI IRIX) and so the build process have
been tuned for these platforms.

A typical set-up session for me for doing Coin development on a virgin
machine looks like this (I'm using SoXt as the GUI library for
demonstration purposes):

  $ cd $HOME
  $ mkdir code compile install
  $ cd code
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P simage
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P Coin
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P SoXt
  [cvs doing its thing]

        Note: you might want to work with a particular branch from the
        CVS, if so use the "-r" option to the "cvs checkout"s above.

        Note2: if you have already checked out the sources at an
        earlier point in time, you just ``cd'' to the sourcecode
        directories and do

                $ cvs -z3 -q update -dP

        instead of the full checkout.


  $ cd $HOME/compile
  $ mkdir simage Coin SoXt

  $ cd $HOME/compile/simage
  $ $HOME/code/simage/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build should complete quickly]

  $ cd $HOME/compile/Coin
  $ $HOME/code/Coin/configure --prefix=$HOME/install --enable-hacking
  [configure running]

        Note the "--enable-hacking" option to configure. This is the
        brilliant part. What happens with this option is that instead
        of making one monolithic libCoin.so file, the Coin library
        will be linked into many shared libraries, one for each
        subdirectory under $HOME/compile/Coin/src/. The brilliance of
        this little trick will be explained later in the walk-through.

  $ make install
  [building will take quite some time, go for a coffee]

  $ cd $HOME/compile/SoXt
  $ $HOME/code/SoXt/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build shouldn't take long]

Ok, that's it. You should now have libsimage, libCoin and libSoXt
built and installed under $HOME/install/lib/.

If you go look in the $HOME/install/lib/ directory, you will see a
bunch of files named lib**something**LINKHACK.so. For each of the
"submodules" in Coin where you will be working, you should now remove
the relevant .so-files and instead symlink them directly from the
build directory. I.e., if you are going to work with the node classes,
execute the following:

  $ cd $HOME/install/lib
  $ ls -c1 *nodesLINKHACK*
  libnodesLINKHACK.la*
  libnodesLINKHACK.so@
  libnodesLINKHACK.so.0@
  libnodesLINKHACK.so.0.0.0*
  $ rm libnodesLINKHACK.so.0.0.0
  $ ln -s $HOME/compile/Coin/src/nodes/.libs/libnodesLINKHACK.so.0.0.0 libnodesLINKHACK.so.0.0.0

(The other two .so-files are just symlinks to the .so.0.0.0 file, so
we don't need to do anything about those.)

You should now be able to do development with very short compile &
link turn-around cycles on the classes in the $HOME/code/Coin/nodes/
directory. Each time you have made a change to the sourcecode, just

  $ cd $HOME/compile/Coin/src/nodes
  $ make

Only the relevant .cpp will now be re-compiled and only the
libnodesLINKHACK.so sub-library will be re-linked. And the
libnodesLINKHACK.so in the install directory which client applications
are using is a symlink pointing to the one in your build directory, so
no re-installation need to happen.


One caveat emptor: if any of the class-definitions change in a non-ABI
compatible way[*] in any of the corresponding .h files, you need to
recompile and relink _all_ sourcecode depending on this class, not
just the class itself. Or core dumps will happen.

[*] There are many, many ways to break ABI compatiblity in C++:

  - variables being added or removed from / to a class, making it's
    sizeof() change
  - functions added or removed
  - functions made virtual or "un-made" from virtual
  - function signatures changed in general

  ... etc. But as long as you're only changing the .cpp files, you
  should be home free.


Right after we implemented this scheme, there was an article called
"Pseudo-Incremental Linking For C/C++" in the Dr Dobb's Journal. The
article is available at

    <URL:http://www.ddj.com/articles/1999/9910/9910d/9910d.htm>

and explains the principles applied fairly well.

=======================================================================
XXX FIXME: complete doc. XXX

* Building Coin for development (UNIX)
	- solutions applied in Coin
                o make install-data
                o make *-am

* Differences, MSWin

* Build hacking, autogen.sh/Autoconf/Automake/Libtool

* Styleguide for code
	- rip out the text from Metadon.conf

* Submitting patches
	- technical walk-through
	- legal aspects

==============================================================================

The following text pertains to the versioning that is set up in configure.ac
(configure.in).

# **************************************************************************
# *******  MAKING RELEASES  ************************************************
# **************************************************************************
#
# Library versioning
# ==================
#
# When making releases, follow these rules:
#
#  * if there has been made any incompatible changes to the ABI¹:
#    COIN_MAJOR_VERSION += 1, COIN_MINOR_VERSION = 0,
#    COIN_MICRO_VERSION = 0.
#
#    (If you don't know if the changes that have been made since last
#    release is binary incompatible with the last ABI, you shouldn't
#    be making releases.)
#
#  * if there has been made additions to the API², but the ABI
#    is still backwards compatible: COIN_MAJOR_VERSION unchanged,
#    COIN_MINOR_VERSION += 1, COIN_MICRO_VERSION = 0.
#
#  * for bugfix releases and other changes which do not change the interface
#    at all, keep COIN_MAJOR_VERSION and COIN_MINOR_VERSION unchanged
#    and COIN_MICRO_VERSION += 1.
#
# Note that our MAJOR.MINOR.MICRO versioning scheme differs somewhat from
# the idea of library versioning applied by Libtool. According to Libtool,
# libraries should be versioned according to a CURRENT.AGE.REVISION scheme.
# Here CURRENT is supposed to be increased by 1 each time the API changes,
# and AGE increased by 1 along with CURRENT each time the API changes in a
# way which keeps the ABI backwards compatible. If compatibility is broken,
# AGE is set to 0 (while CURRENT is still increased by 1). The REVISION
# number has the same semantics as our MICRO number.
#
# To cooperate in a painless way with Libtool, we choose to "convert" our
# MAJOR.MINOR.MICRO scheme to Libtool's idea of versioning like this:
#
#    * Libtool's CURRENT number is increased when our MAJOR number is
#      increased.
#
#    * Libtool's AGE number is always kept at 0 (i.e. we will never make
#      ABI compatible releases where we increase the MAJOR number).
#
#    * Libtool's REVISION number will be a combination of our MINOR and
#      MICRO number, like this: REVISION = MINOR * 100 + MICRO, so we get
#      a REVISION number monotonically increasing in the way we want.
#
#      Note that this little "simplification" has two important
#      ramifications: 1) we can't make more than 99 bugfix-releases of
#      the library unless a MINOR or MAJOR version increase has happened,
#      2) we need to keep a release history log to map from Libtool numbers
#      back to our "native" MACRO.MINOR.MICRO versioning, as Libtool encodes
#      the filename of the library with it's own CURRENT.AGE.REVISION scheme.
#      This way it'll still be easy for us to find out which version a
#      bugreport belongs to: we must tell the user to check out the full
#      filename of the library, then we can just look up the MAJOR.MINOR.MICRO
#      number from the release history log below.
#
#
# **************************************************************************
# CVS maintenance
# ===============
#
# When making a release from the HEAD branch, increase the MAJOR number
# and make a new branch as follows (from the HEAD):
#
#   $ cd [coin_srcdir_HEADbranch]
#   $ cvs tag -b coin-MAJOR-0
#
# (The explicit mention of "coin" in the branch name is necessary
# because we also tag this name onto all included CVS modules.)
#
# Note that new releases from the HEAD branch should only happen when
# there has been incompatible interface changes.
#
#
# When adding new functionality while keeping backward ABI compatibility,
# increase the MINOR number and make a new branch as follows:
#
#   $ cd [coin_srcdir_MAJORbranch]
#   $ cvs tag -b coin-MAJOR-MINOR
#
# (Where MINOR>0 always).
#
#
# Bugfix releases should be handled by setting a tag on the
# coin-MAJOR-MINOR with the latest MAJOR.MINOR.x release,
# like this:
#
#   $ cd [coin_srcdir_MAJORMINORbranch]
#   $ cvs tag coin-MAJOR-MINOR-MICRO
#
# (Where MICRO>0 always).
#
# **************************************************************************
# Distribution binaries
# =====================
#
#  * MSWindows SDK: this is constructed as a self-extracting InstallShield
#    package. Run ``configure'' and ``make install'' on an MSWin-box with
#    the correct setup (latest Cygwin, MSVC++ v6.0 and InstallShield Express
#    v2.12), then execute
#
#         $ cd [coin_builddir]/build
#         $ make ispkg
#
#    (Installshield's IsxBuild.exe need to be in your path.)
#
#    A self-extracting executable SETUPEX.EXE with the InstallShield install
#    should then be available under [coin_builddir]/build/coin/. Move
#    to <ftp://ftp.sim.no/pub/coin/bin/win32/coin-@COIN_VERSION@.exe>.
#
#  * RPM packages: follow the instructions at the top of the
#    build/coin.spec.in file, make one package for each major platform
#    version we have access to (RedHat v5, v6, v7, Mandrake?, SuSE, etc)
#    for the architectures we want (i386, ...). Place packages under
#    <ftp://ftp.sim.no/pub/coin/bin/[platform]/[arch]/>.
#
# **************************************************************************
# Release history
# ===============
#
# Release version     | Libtool version   |                 |
# (MAJOR.MINOR.MICRO) | (CURRENT.AGE.REV) | CVS Branch name | Tag name
# --------------------+-------------------+-----------------+-----------------
#     0.9.99          |     0.0.999       |      HEAD       | coin-0-9-99
#
#
# **************************************************************************
# Footnotes
# =========
#
# ¹ Application Binary Interface. This covers any publicly exposed
#   functions, function signatures, structures (and classes for C++
#   code). If any functions has been removed or changed, or if any
#   structures/classes has been modified in any way, the ABI has
#   most likely been made incompatible with earlier releases.
#
# ² Application Programmer's Interface. This is the functions and data
#   structures/classes exposed to the application programmer for
#   interaction with the library.
#
# **************************************************************************
