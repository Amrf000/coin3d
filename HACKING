If you want to work _with_ the Coin sourcecode (not just writing
applications _using_ the Coin library) -- for helping us fixing bugs,
improve performance, or whatever reasons -- this file contains some
hints and tips for you.

==============================================================================

1 The Bleeding Edge
===================

First of all, you should make sure you are building from the latest
sources from the CVS branch you want to work with. This is done by
using the Concurrent Versioning System for staying in sync with the
sourcecode repository we at Systems in Motion are using. Follow the
instructions on the webpages at <URL:http://www.coin3d.org/>.

Be aware that Coin has two source repositories.  "Coin" is the head
development repository which is unstable and may contain unportable
code and break binary compatibility from time to time.  "Coin-1" is
the repository we release the Coin 1.* releases from and will always
contain stable code that does not break upwards binary compatibility.
You can hack on either, but for your application development efforts'
sake you might want to follow Coin-1.

If you are not familiar with CVS, check out the CVS homepages at
<URL:http://cvshome.org>.


2 Surviving a Large C++ Project
===============================

The main problem all large C or C++ projects bump into sooner or later
is that the turn-around time for doing compile, link and run gets too
long for development to be efficient. When we're talking re-linking of
library files of >30MB (with debug information), its gonna get painful
to do rapid incremental bugfixing / testing cycles.

So I'm going to explain now how we at SIM have (more or less
fundamentally) solved this problem for our core Coin library. First of
all: use a "UNIX-like" system. MSWindows systems are no good for
working with the kind of setup we have, we do all new development on
UNIX systems (mostly Linux and SGI IRIX) and so the build process have
been tuned for these platforms.

A typical set-up session for me for doing Coin development on a virgin
machine looks like this (I'm using SoXt as the GUI library for
demonstration purposes):

  $ cd $HOME
  $ mkdir code compile install
  $ cd code
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P simage-1
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P Coin-1
  [cvs doing its thing]
  $ cvs -z3 -d :pserver:cvs@cvs.sim.no:/export/cvsroot checkout -P SoXt
  [cvs doing its thing]

        Note: you might want to work with a particular branch from the
        CVS, if so use the "-r" option to the "cvs checkout"s above.

        Note2: if you have already checked out the sources at an
        earlier point in time, you just ``cd'' to the sourcecode
        directories and do

                $ cvs -z3 -q update -dP

        instead of the full checkout.


  $ cd $HOME/compile
  $ mkdir simage Coin SoXt

  $ cd $HOME/compile/simage
  $ $HOME/code/simage-1/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build should complete quickly]

  $ cd $HOME/compile/Coin
  $ $HOME/code/Coin-1/configure --prefix=$HOME/install --enable-hacking
  [configure running]

        Note the "--enable-hacking" option to configure. This is the
        brilliant part. What happens with this option is that instead
        of making one monolithic libCoin.so file, the Coin library
        will be linked into many shared libraries, one for each
        subdirectory under $HOME/compile/Coin/src/. The brilliance of
        this little trick will be explained later in the walk-through.

  $ make install
  [building will take quite some time, go for a coffee]

  $ cd $HOME/compile/SoXt
  $ $HOME/code/SoXt/configure --prefix=$HOME/install
  [configure running]
  $ make install
  [build shouldn't take long]

Ok, that's it. You should now have libsimage, libCoin and libSoXt
built and installed under $HOME/install/lib/.

If you go look in the $HOME/install/lib/ directory, you will see a
bunch of files named lib**something**LINKHACK.so. For each of the
"submodules" in Coin where you will be working, you should now remove
the relevant .so-files and instead symlink them directly from the
build directory. I.e., if you are going to work with the node classes,
execute the following:

  $ cd $HOME/install/lib
  $ ls -c1 *nodesLINKHACK*
  libnodesLINKHACK.la*
  libnodesLINKHACK.so@
  libnodesLINKHACK.so.0@
  libnodesLINKHACK.so.0.0.0*
  $ rm libnodesLINKHACK.so.0.0.0
  $ ln -s $HOME/compile/Coin/src/nodes/.libs/libnodesLINKHACK.so.0.0.0 libnodesLINKHACK.so.0.0.0

(The other two .so-files are just symlinks to the .so.0.0.0 file, so
we don't need to do anything about those.)

You should now be able to do development with very short compile &
link turn-around cycles on the classes in the $HOME/code/Coin/nodes/
directory. Each time you have made a change to the sourcecode, just

  $ cd $HOME/compile/Coin/src/nodes
  $ make

Only the relevant .cpp will now be re-compiled and only the
libnodesLINKHACK.so sub-library will be re-linked. And the
libnodesLINKHACK.so in the install directory which client applications
are using is a symlink pointing to the one in your build directory, so
no re-installation need to happen.


One caveat emptor: if any of the class-definitions change in a non-ABI
compatible way[*] in any of the corresponding .h files, you need to
recompile and relink _all_ sourcecode depending on this class, not
just the class itself. Or core dumps will happen.

[*] There are many, many ways to break ABI compatiblity in C++:

  - variables being added or removed from / to a class, making it's
    sizeof() change
  - functions added or removed
  - functions made virtual or "un-made" from virtual
  - function signatures changed in general

  ... etc. But as long as you're only changing the .cpp files, you
  should be home free.


Right after we implemented this scheme, there was an article called
"Pseudo-Incremental Linking For C/C++" in the Dr Dobb's Journal. The
article is available at

    <URL:http://www.ddj.com/articles/1999/9910/9910d/9910d.htm>

and explains the principles applied fairly well.

=======================================================================
XXX FIXME: complete doc. XXX

* Building Coin for development (UNIX)
        - solutions applied in Coin
                o make install-data
                o make *-am

* Differences, MSWin

* Build hacking, autogen.sh/Autoconf/Automake/Libtool

* Styleguide for code
        - rip out the text from Metadon.conf

* Submitting patches
        - technical walk-through
        - legal aspects

==============================================================================

The following text pertains to the versioning that is set up in configure.ac
(configure.in).

Library versioning
==================

When making releases, we follow these rules:

* if there has been made any incompatible changes to the ABI¹:
    COIN_MAJOR_VERSION += 1,
    COIN_MINOR_VERSION = 0,
    COIN_MICRO_VERSION = 0.

   (If you don't know if the changes that have been made since last
   release is binary incompatible with the last ABI, you shouldn't
   be making releases.)

* if there has been made additions to the API², but the ABI
  is still backwards compatible: COIN_MAJOR_VERSION unchanged,
  COIN_MINOR_VERSION += 1, COIN_MICRO_VERSION = 0.

* for bugfix releases and other changes which do not change the interface
  at all, keep COIN_MAJOR_VERSION and COIN_MINOR_VERSION unchanged
  and COIN_MICRO_VERSION += 1.

Note that our MAJOR.MINOR.MICRO versioning scheme differs somewhat from
the idea of library versioning applied by Libtool. According to Libtool,
libraries should be versioned according to a CURRENT.AGE.REVISION scheme.
Here CURRENT is supposed to be increased by 1 each time the API changes,
and AGE increased by 1 along with CURRENT each time the API changes in a
way which keeps the ABI backwards compatible. If compatibility is broken,
AGE is set to 0 (while CURRENT is still increased by 1). The REVISION
number has the same semantics as our MICRO number.

To cooperate in a painless way with Libtool, we choose to "convert" our
MAJOR.MINOR.MICRO scheme to Libtool's idea of versioning like this:

* Libtool's CURRENT number is increased when the MAJOR or MINOR number is
  changed.  If development and realeases were dune in a linear fashion, we
  would just have to increase CURRENT by one when the above happens, but
  since we intend to continue to support Coin 1.* after the release of
  Coin 2.* we have had to make up a different scheme.  What we have done is
  to reserve room for 20 minor releases between each major release.  This
  should hopefully be more than enough.  With this premise, we can calculate
  CURRENT with the formula MAJOR * 20 + MINOR.  This will ensure that
  CURRENT for 2.0 will be greater than CURRENT for 1.3 (and 1.17 for that
  matter).

  Note that this scheme has the "strange" (it's actually completely natural)
  effect that Coin 1.0 will be found as /usr/local/lib/libCoin.so.20.*
  (for Linux) and Coin 2.0 will be libCoin.so.40.*.

* Libtool's AGE number is the number of previous CURRENT version numbers
  that the library is binary compatible with.  This should always be the same
  number as MINOR is - when we make a new release with a new MAJOR number
  and 0 as MINOR number, ABI compatibility *will* be broken.

* Libtool's REVISION number is the number of the release with the exact same
  API/ABI as the previous release.  This is typical for patch-releases
  where some implementation bugs are fixed without touching anything in the
  library API.  In other words, when we up the MICRO number.  This means
  REVISION = MICRO.

==============================================================================

CVS maintenance
===============

New "Coin-MAJOR" repositories will be branched off the head "Coin" repository.
When this happens, the Coin repository will be tagged with the symbolic name
"coin-MAJOR_0_0".

All releases will be made from the Coin-MAJOR repositories.  When a new
release is made from one of those, the sources will be tagged with the
symbolic name "coin-MAJOR_MINOR_MICRO".  This was forgotten for the
Coin-1.0.0 release, but for MAJOR.0.0 releases this is not very important
as it will coincide with the initial import of the repository.

Releases made from Coin-MAJOR repositories will be in sequence.  When the
MINOR version number is increased, no more releases of the MINOR - 1 branch
will be made.


Making Releases
===============

When a new release is to be made, configure.ac must be updated with new
version information.  Make sure COIN_BETA is set to [] (empty), and the
release version number is set up.  Run bootstrap and check that
"make distcheck" works.  Commit the changes with a message about setting
the version number to MAJOR.MINOR.MICRO.

Add a CVS tag on the new version number.
  $ cvs tag coin-MAJOR_MINOR_MICRO

Edit configure.ac again and increase micro (unless a new minor will be the
next release) and set COIN_BETA to [a].  Rerun bootstrap, and commit the
new setup with a message about setting the version number again.

These two version-increment commits should happen without getting any
unrelated commits inbetween them so there won't be multiple states of
the CVS repository with a release version number.

Then go back to the tag (update -dP -r coin-MAJOR_MINOR_MICRO) and
prepare the release.

Source release tarballs are created with "make dist".  Binary releases are
created from the source release tarball.

==============================================================================

Coin Code Standard
==================

* If the code you write is not 100% complete;

  - Leave a "FIXME" message if you believe the code is fairly correct,
    but you are unsure and have not checked the correctness yet, or if
    there are known deficiencies. This includes cases like ambiguities
    in the OIV docs that will require some investigation to resolve,
    error-cases or places where one should be more robust that haven't
    been fixed yet due to time constraints, etc.

  - Insert "COIN_STUB();" statements if the code lacks certain
    important functionality, so situations where unimplemented
    features are used will be detected at run-time.

  - Leave FIXMEs if you see obvious cases for performance improvements
    which should be explored.

  A FIXME-message must include a description of the problem, who wrote
  the message, and when.  Please include whatever you have already
  found out about the problem in the FIXME text, so your next of kin
  don't have to painstakingly re-do all the thought-work you already
  have laid down.  Example:

    // FIXME: should be possible to simplify cylinder test, since this
    // cylinder is aligned with the y-axis. 19991110 pederb.

  or

     // FIXME: this looks wrong, shouldn't we rather reset the
     // alignment value to what it was previously?  20010824 mortene.

  This goes also for other keywords in comments (see below).  It makes
  it much easier when others try to fix code that doesn't work.  You
  will know who to ask if you don't understand the problem, and the
  date could indicate among other things the urgency of the problem.
 
* If blocks of code are commented out (obsoleted) to make place for
  new code, or because it has become superfluous, one should mark it
  like the example below if it is a large block of code, if the new
  code is very experimental, or if the new code is obfuscated
  (e.g. because of optimizations).

    #if 0// OBSOLETE: <textual description>. <yyyymmdd userid>.
    ...old code...
    #else // short description of new code
    ...new code...
    #endif // newcode

  So do _not_ leave any code which has been commented out with the
  language constructs "// ..." or "/* ... */" in anything you check
  into CVS, at least not without commenting _why_ the code is still
  present.  It's a bloody pain in the ass trying to figure out why
  commented-out code is still present in a source file (is it new code
  which *might* fix a bug, but which haven't been tested yet? is it
  old code found to be buggy which have been removed? is it commented
  out because it is a new feature which is yet to be completed? etc
  etc etc).  People who do this should be taken out behind the barn to
  be shot.

* During debugging, write debug code like this:

    #if COIN_DEBUG && 1 // debug
      SoDebugError::postInfo(...
    #endif // debug

  Then, flip the "#if COIN_DEBUG && 1" to "#if COIN_DEBUG && 0" if
  there is a chance that the debug information might be useful later.
  If not, remove it before making a patch or checking in.

  If there are many debug statements in the same category, use a
  define for that category (#if DEBUG_<category>) and define it to 0
  at the top of the file before checking in the code.  See
  src/sensors/SoSensorManager.cpp for examples of how this should be
  done.

* Do not under any circumstances use printf() / fprintf() / puts() or
  related functions for output.  It should not be necessary -- the
  Coin class SoDebugError (and SoReadError) was implemented for a
  reason.  Debug messages with printf() / fprintf() is extremely
  uncool when you use Coin as a DLL under Windows (it's likely to
  cause mysterious crashes), and besides it's bloody irritating to
  walk through the code later to remove them.

* Code formatting rules. The default is to use Kernighan and Ritchie style.

  - Braces: keep opening braces on the end of the line, and closing braces
    at the start. Like this:

      if (...) {
        ...
      }

      And not like this:

      if (...)
      {
        ...
      }

    The exception from this rule is functions, which should have the
    opening brace on the next line.

  - Indentation: use 2 spaces extra for each level of nesting.
    *Never* use tabulator characters (ie ASCII code 0x09).

  - Spacing: use 1 space after commas and around operators (like +, -,
    *, /, ==, &&, etc), but not after or before parentheses.

    Like this:

      if (val) { i = sqrt(a) * func(b, c); }

    Not like this:

      if ( val ) { i=sqrt(a)*func(b,c); }

  - Naming: class names should be uppercased for each word, function
    names for each word except the first one, variable names should be
    all lowercase, and defines, enums and constants should be all
    uppercase. Example:

      float
      MathClass::calculateValue(float in)
      {
        const float FACTOR = 2.78;
        ...
        ...
      }

==============================================================================

Footnotes
=========

¹ Application Binary Interface. This covers any publicly exposed
  functions, function signatures, structures (and classes for C++
  code). If any functions has been removed or changed, or if any
  structures/classes has been modified in any way, the ABI has most
  likely been made incompatible with earlier releases.

² Application Programmer's Interface. This is the functions and data
  structures/classes exposed to the application programmer for
  interaction with the library.

==============================================================================
